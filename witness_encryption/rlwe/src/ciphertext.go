package src

import (
	"bufio"
	"fmt"
	"io"
	"runtime"

	"github.com/Pro7ech/lattigo/ring"
	"github.com/Pro7ech/lattigo/rlwe"
	"github.com/Pro7ech/lattigo/utils/buffer"
	"github.com/Pro7ech/lattigo/utils/concurrency"
	"github.com/Pro7ech/lattigo/utils/sampling"
)

type Ciphertext struct {
	Seed [32]byte
	A    ring.RNSPoly
	C    ring.RNSPoly
	D    [][2]ring.RNSPoly
}

func (c *Ciphertext) Expand(params rlwe.Parameters) {

	Rq := params.RingQ()

	source := sampling.NewSource(c.Seed)
	XD, err := ring.NewSampler(nil, Rq.ModuliChain(), params.Xs())
	if err != nil {
		panic(err)
	}

	c.D = make([][2]ring.RNSPoly, LogWitness)

	seeds := make([][2][32]byte, LogWitness)
	for i := range seeds {
		seeds[i][0] = source.NewSeed()
		seeds[i][1] = source.NewSeed()
		c.D[i][0] = Rq.NewRNSPoly()
		c.D[i][1] = Rq.NewRNSPoly()
	}

	rm := concurrency.NewRessourceManager[bool](make([]bool, runtime.NumCPU()))

	for i := range seeds {
		rm.Run(func(b bool) (err error) {
			genD(Rq, c.D[i][0], XD.WithSource(sampling.NewSource(seeds[i][0])))
			return nil
		})

		rm.Run(func(b bool) (err error) {
			genD(Rq, c.D[i][1], XD.WithSource(sampling.NewSource(seeds[i][1])))
			return nil
		})
	}

	if err := rm.Wait(); err != nil {
		panic(fmt.Errorf("%w", err))
	}
}

// BinarySize returns the serialized size of the object in bytes.
func (ct Ciphertext) BinarySize() (size int) {
	return 32 + ct.A.BinarySize() + ct.C.BinarySize()
}

// WriteTo writes the object on an io.Writer. It implements the io.WriterTo
// interface, and will write exactly object.BinarySize() bytes on w.
//
// Unless w implements the buffer.Writer interface (see gofhe/utils/buffer/writer.go),
// it will be wrapped into a bufio.Writer. Since this requires allocations, it
// is preferable to pass a buffer.Writer directly:
//
//   - When writing multiple times to a io.Writer, it is preferable to first wrap the
//     io.Writer in a pre-allocated bufio.Writer.
//   - When writing to a pre-allocated var b []byte, it is preferable to pass
//     buffer.NewBuffer(b) as w (see gofhe/utils/buffer/buffer.go).
func (ct Ciphertext) WriteTo(w io.Writer) (n int64, err error) {
	switch w := w.(type) {
	case buffer.Writer:

		var inc int64

		if inc, err = buffer.Write(w, ct.Seed[:]); err != nil {
			return n + inc, err
		}

		n += inc

		if inc, err = ct.C.WriteTo(w); err != nil {
			return n + inc, err
		}

		n += inc

		if inc, err = ct.A.WriteTo(w); err != nil {
			return n + inc, err
		}

		n += inc

		return n, w.Flush()
	default:
		return ct.WriteTo(bufio.NewWriter(w))
	}
}

// ReadFrom reads on the object from an io.Writer. It implements the
// io.ReaderFrom interface.
//
// Unless r implements the buffer.Reader interface (see see gofhe/utils/buffer/reader.go),
// it will be wrapped into a bufio.Reader. Since this requires allocation, it
// is preferable to pass a buffer.Reader directly:
//
//   - When reading multiple values from a io.Reader, it is preferable to first
//     first wrap io.Reader in a pre-allocated bufio.Reader.
//   - When reading from a var b []byte, it is preferable to pass a buffer.NewBuffer(b)
//     as w (see gofhe/utils/buffer/buffer.go).
func (ct *Ciphertext) ReadFrom(r io.Reader) (n int64, err error) {
	switch r := r.(type) {
	case buffer.Reader:

		var inc int64

		if inc, err = buffer.Read(r, ct.Seed[:]); err != nil {
			return n + inc, err
		}

		n += inc

		if inc, err = ct.C.ReadFrom(r); err != nil {
			return n + inc, err
		}

		n += inc

		if inc, err = ct.A.ReadFrom(r); err != nil {
			return n + inc, err
		}

		n += inc

		return n, err

	default:
		return ct.ReadFrom(bufio.NewReader(r))
	}
}

// MarshalBinary encodes the object into a binary form on a newly allocated slice of bytes.
func (ct Ciphertext) MarshalBinary() (data []byte, err error) {
	buf := buffer.NewBufferSize(ct.BinarySize())
	_, err = ct.WriteTo(buf)
	return buf.Bytes(), err
}

// UnmarshalBinary decodes a slice of bytes generated by
// MarshalBinary or WriteTo on the object.
func (ct *Ciphertext) UnmarshalBinary(data []byte) (err error) {
	_, err = ct.ReadFrom(buffer.NewBuffer(data))
	return
}
